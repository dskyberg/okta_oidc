use actix_session::Session;
use actix_web::{http::StatusCode, web, Responder};
use log::info;
use openidconnect::core::CoreResponseType;
use openidconnect::{AuthenticationFlow, CsrfToken, Nonce, Scope};

use crate::AppState;

pub async fn login(session: Session, app_state: web::Data<AppState>) -> actix_web::Result<impl Responder> {
    
    let scopes = app_state.config.oidc_scopes.iter().map(|scope| Scope::new(scope.to_owned())).collect::<Vec<Scope>>();
    // Generate the authorization URL to which we'll redirect the user.
    let (authorize_url, csrf_state, nonce) = app_state
        .oidc_client
        .authorize_url(
            AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
            CsrfToken::new_random,
            Nonce::new_random,
        )
        .add_scopes(scopes)
        // This example is requesting access to the "calendar" features and the user's profile.
        .url();

    // The nonce generated by the client, will be returned by the Auth Server.  Save it, to
    // hand back to the server in the token exchange step.
    session.insert("oauth_nonce", nonce)?;

    // This value should not be used for validation.  Use the nonce instead.  But this value can
    // be used to look up state.  We don't really need it, since we're storing sessions.  But what
    // the heck, keep it around anyway.
    session.insert("oauth_state", csrf_state)?;

    // Show the redirect url for fun...
    info!("Redirecting to: {}", &authorize_url);

   Ok(web::Redirect::to(authorize_url.to_string()).using_status_code(StatusCode::FOUND))
}
