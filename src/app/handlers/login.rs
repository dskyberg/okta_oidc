use std::sync::Arc;

use actix_session::Session;
use actix_web::{
    http::StatusCode,
    web::{Data, Redirect},
    Responder, Result,
};
use openidconnect::{core::CoreResponseType, PkceCodeChallenge};
use openidconnect::{AuthenticationFlow, CsrfToken, Nonce, Scope};
use tracing::*;

use crate::AppState;

#[instrument(skip(session, app_state))]
pub async fn login(session: Session, app_state: Data<Arc<AppState>>) -> Result<impl Responder> {
    let oidc_config = &app_state.config.oidc;

    let scopes = oidc_config
        .scopes
        .iter()
        .map(|scope| Scope::new(scope.to_owned()))
        .collect::<Vec<Scope>>();

    // Generate the authorization URL to which we'll redirect the user.
    let mut auth_request = app_state
        .oidc_client
        .inner()
        .authorize_url(
            AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
            CsrfToken::new_random,
            Nonce::new_random,
        )
        .add_scopes(scopes);

    if oidc_config.use_pkce {
        // Generate a PKCE challenge.
        let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
        session.insert("pkce_verifier", pkce_verifier)?;
        info!("Adding PKCE challenge to URL: {:?}", &pkce_challenge);

        auth_request = auth_request.set_pkce_challenge(pkce_challenge);
    } else {
        info!("PKCE is disabled")
    }

    // This example is requesting access to the "calendar" features and the user's profile.
    let (authorize_url, csrf_state, nonce) = auth_request.url();

    // The nonce generated by the client, will be returned by the Auth Server.  Save it, to
    // hand back to the server in the token exchange step.
    session.insert("oauth_nonce", nonce.clone())?;

    // This value should not be used for validation.  Use the nonce instead.  But this value can
    // be used to look up state.  We don't really need it, since we're storing sessions.  But what
    // the heck, keep it around anyway.
    session.insert("oauth_state", csrf_state.clone())?;

    // Show the redirect url for fun...
    info!(
        "Redirecting to: {} state: {}, nonce: {}",
        &authorize_url,
        csrf_state.secret(),
        nonce.secret()
    );
    Ok(Redirect::to(authorize_url.to_string()).using_status_code(StatusCode::FOUND))
}
